import builtins
import sys

from typing import Any, Container, Dict, IO, Iterable, List, Mapping, Optional, overload, Sequence, Sized, SupportsAbs, SupportsComplex, SupportsFloat, SupportsInt, Text, Tuple, Type, TypeVar, Union

# union of built-in scalar types
# see https://docs.scipy.org/doc/numpy/reference/arrays.scalars.html
_builtinScalarUnion = Union[
    # TODO: fill the union with aliases from _type_aliases.py
    int, float, bool
]

# union of types that can be used as dtype
# see: https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html#specifying-and-constructing-data-types
_dtypeUnion = Union[
    dtype,
    None,
    _builtinScalarUnion,
    str,
    Tuple[Any, int],
    Tuple[Any, Union[int, Sequence[int]]],
    # [(field_name, field_dtype, field_shape), ...]
    List[
        Union[
            Tuple[Union[str, Tuple[str, str]], Any],
            Tuple[Union[str, Tuple[str, str]], Any, Union[int, Sequence[int]]]
        ]
    ],
    # {'names': ..., 'formats': ..., 'offsets': ..., 'titles': ..., 'itemsize': ...}
    Dict[str, Union[Sequence[str], Sequence[Any], Sequence[int], Sequence[Union[bytes, Text, None]], int]],
    # {'field1': ..., 'field2': ..., ...}
    Dict[str, Tuple[Any, int]],
    # (base_dtype, new_dtype)
    Tuple[Any, Any]
]

# actual dtype
# see: https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html
class dtype:
    def __init__(self, obj: _dtypeUnion, align: bool = ..., copy: bool = ...) -> None: ...

    # properties
    @property
    def alignment(self) -> int: ...
    @property
    def base(self) -> dtype: ...
    @property
    def byteorder(self) -> str: ...
    @property
    def char(self) -> str: ...
    @property # https://docs.scipy.org/doc/numpy/reference/arrays.interface.html
    def descr(self) -> List[Union[Tuple[str, str], Tuple[str, str, Tuple[int, ...]]]]: ...
    @property
    def fields(self) -> Optional[Mapping[str, Union[Tuple[dtype, int], Tuple[dtype, int, Any]]]]: ...
    @property
    def flags(self) -> int: ...
    @property
    def hasobject(self) -> bool: ...
    @property
    def isbuiltin(self) -> int: ...
    @property
    def isnative(self) -> bool: ...
    @property
    def isalignedstruct(self) -> bool: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def kind(self) -> str: ...
    @property
    def metadata(self) -> Any: ...
    @property
    def name(self) -> str: ...
    @property
    def names(self) -> Optional[Tuple[str, ...]]: ...
    @property
    def ndim(self) -> int: ...
    @property
    def num(self) -> int: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def subdtype(self) -> Optional[Tuple[dtype, Tuple[int, ...]]]: ...
    @property
    def str(self) -> builtins.str: ...
    @property
    def type(self) -> Type[_generic]: ...

    # methods
    def newbyteorder(self, new_order: str = ...) -> dtype: ...

_generic = Any
_array_like = Sequence[Any]
_Tndarray = TypeVar("_Tndarray", bound=ndarray)

# A 1-D iterator over the array
# see: https://docs.scipy.org/doc/numpy/reference/generated/numpy.flatiter.htm
class flatiter:
    @property
    def base(self) -> ndarray: ...
    @property
    def coords(self) -> Tuple[int, ...]: ...
    @property
    def index(self) -> int: ...

    def copy(self) -> ndarray: ...
    def __iter__(self) -> flatiter: ...
    def __next__(self) -> Any: ...

class ndarray:
    # properties
    @property
    def base(self) -> Optional[ndarray]: ...
    @property
    def ctypes(self) -> Any: ...
    @property
    def data(self) -> memoryview: ...
    @property
    def dtype(self) -> _dtypeUnion: ...
    @property
    def flags(self) -> Dict[str, bool]: ...
    @property
    def flat(self) -> flatiter: ...
    @property
    def imag(self) -> ndarray: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def nbytes(self) -> int: ...
    @property
    def ndim(self) -> int: ...
    @property
    def real(self) -> ndarray: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def size(self) -> int: ...
    @property
    def T(self) -> ndarray: ...

    def all(self, axis: Union[int, Tuple[int, ...]] = ..., out: ndarray = ..., keepdims: bool = ...) -> Union[bool, ndarray]: ...
    def any(self, axis: Union[int, Tuple[int, ...]] = ..., out: ndarray = ..., keepdims: bool = ...) -> Union[bool, ndarray]: ...
    def argmax(self, axis: int = ..., out: array_like = ...) -> ndarray: ...
    def argmin(self, axis: int = ..., out: array_like = ...) -> ndarray: ...
    def argpartition(self, kth: Union[int, Sequence[int]], axis: int = ..., kind: str = ..., order: Union[str, Sequence[str]] = ...) -> ndarray: ...
    def argsort(self, axis: int = ..., kind: str = ..., order: Union[str, Sequence[str]] = ...) -> ndarray: ...
    def astype(self, dtype: _dtypeUnion, order: str = 'K', casting: str = 'unsafe', subok: bool = ..., copy: bool = ...) -> ndarray: ...
    def byteswap(self, inplace: bool = False) -> ndarray: ...
    def choose(self, choices: Sequence[array_like], out: ndarray = ..., mode: str = 'raise') -> ndarray: ...
    def clip(self, min: Union[_generic, array_like] = ..., max: Union[_generic, array_like] = ..., out: ndarray = ...) -> ndarray: ...
    def compress(self, condition: Sequence[bool], axis: int = ..., out: ndarray = ...) -> ndarray: ...
    def copy(self, order: str = 'C') -> ndarray: ...
    def cumprod(self, axis: int = ..., dtype: _dtypeUnion = ..., out: ndarray = ...) -> ndarray: ...
    def cumsum(self, axis: int = ..., dtype: _dtypeUnion = ..., out: ndarray = ...) -> ndarray: ...
    def diagonal(self, offset: int = ..., axis1: int = ..., axis2: int = ...) -> ndarray: ...
    def dot(self, b: array_like, out: ndarray = ...) -> ndarray: ...
    def dump(self, file: str) -> None: ...
    def dumps(self) -> bytes: ...
    def fill(self, value: _generic) -> None: ...
    def flatten(self, order: str = ...) -> ndarray: ...
    def getfield(self, dtype: _dtypeUnion, offset: int = ...) -> ndarray: ...
    @overload
    def item(self, *args: int) -> _generic: ...
    @overload
    def item(self, args: Tuple[int, ...]) -> _generic: ...
    @overload
    def itemset(self, value: _generic) -> None: ...
    @overload
    def itemset(self, item: Union[int, Tuple[int, ...]], value: _generic) -> None: ...
    def max(self, axis: Union[int, Tuple[int, ...]] = ..., out: ndarray = ..., keepdims: bool = ...) -> Union[ndarray, _generic]: ...
    def mean(self, axis: Union[int, Tuple[int, ...]] = ..., dtype: _dtypeUnion = ..., out: ndarray = ..., keepdims: bool = ...) -> Union[ndarray, _generic]: ...
    def min(self, axis: Union[int, Tuple[int, ...]] = ..., out: ndarray = ..., keepdims: bool = ...) -> Union[ndarray, _generic]: ...
    def newbyteorder(self, new_order: str = 'S') -> dtype: ...
    def nonzero(self) -> Tuple[ndarray]: ...
    def partition(self, kth: Union[int, Sequence[int]], axis: int = -1, kind: str = 'introselect', order: Union[str, Sequence[str]] = ...) -> None: ...
    def prod(self, axis: Union[int, Tuple[int, ...]] = ..., dtype: _dtypeUnion = ..., out: ndarray = ..., keepdims: bool = False) -> ndarray: ...
    def ptp(self, axis: Union[int, Tuple[int, ...]] = ..., out: array_like = ..., keepdims: bool = ...) -> ndarray: ...
    def put(self, ind: Sequence[int], v: array_like, order: str = ...) -> None: ...
    def ravel(self, order: str = ...) -> ndarray: ...
    def repeat(self, repeats: Union[int, Sequence[int]] = ..., axis: int = ...) -> ndarray: ...
    @overload
    def reshape(self, shape: Sequence[int], order: str = ...) -> ndarray: ...
    @overload
    def reshape(self, *shape: int, order: str = ...) -> ndarray: ...
    @overload
    def resize(self, new_shape: Sequence[int], *, refcheck: bool = True) -> None: ...
    @overload
    def resize(self, *new_shape: int, refcheck: bool = True) -> None: ...
    def round(self, decimals: int = 0, out: ndarray = ...) -> ndarray: ...
    def searchsorted(self, v: array_like, side: str = ..., sorter: Sequence[int] = ...) -> List[int]: ...
    def setfield(self, val: object, dtype: _dtypeUnion, offset: int = ...) -> None: ...
    def setflags(self, write: bool = ..., align: bool = ..., uic: bool = ...) -> None: ...
    def sort(self, axis: int = -1, kind: str = 'quicksort', order: Union[str, Sequence[str]] = ...) -> None: ...
    def squeeze(self, axis: Union[int, Tuple[int, ...]] = ...) -> ndarray: ...
    def std(self, axis: Union[int, Sequence[int]] = ..., dtype: _dtypeUnion = ..., out: ndarray = ..., ddof: int = 0, keepdims: bool = ...) -> ndarray: ...
    def strides(self) -> Tuple[int, ...]: ...
    def sum(self, axis: Union[int, Sequence[int]] = ..., dtype: _dtypeUnion = ..., out: ndarray = ..., keepdims: bool = ...) -> ndarray: ...
    def swapaxes(self, axis1: int, axis2: int) -> ndarray: ...
    def take(self, indices: array_like, axis: int = ..., out: ndarray = ..., mode: str = ...) -> ndarray: ...
    def tobytes(self, order: Optional[str] = ...) -> bytes: ...
    def tofile(self, fid: Union[IO[bytes], str], sep: str = ..., format: str = ...) -> None: ...
    def tolist(self) -> List[Any]: ...
    def tostring(self, order: Optional[str] = ...) -> bytes: ...
    def trace(self, offset: int = 0, axis1: int = 0, axis2: int = 1, dtype: _dtypeUnion = ..., out: ndarray = ...) -> ndarray: ...
    def transpose(self, axes: Sequence[int]) -> ndarray: ...
    def var(self, axis: Union[int, Tuple[int, ...]] = ..., dtype: _dtypeUnion = ..., out: ndarray = ..., ddof: int = 0, keepdims: bool = ...) -> ndarray: ...
    @overload
    def view(self, dtype: Type[_Tndarray]) -> _Tndarray: ...
    @overload
    def view(self, dtype: _dtypeUnion = ...) -> ndarray: ...
    @overload
    def view(self, dtype: _dtypeUnion, type: Type[_Tndarray]) -> _Tndarray: ...
    @overload
    def view(self, *, type: Type[_Tndarray]) -> _Tndarray: ...

@overload
def arange(stop: _builtinScalarUnion, step: _builtinScalarUnion = ..., dtype: _dtypeUnion = ...)  -> ndarray: ...
@overload
def arange(start: _builtinScalarUnion, stop: _builtinScalarUnion, step: _builtinScalarUnion = ..., dtype: _dtypeUnion = ...)  -> ndarray: ...
def array(object: _array_like, dtype: _dtypeUnion = ..., copy: bool = ..., subok: bool = ..., ndmin: int = ...) -> ndarray: ...
def empty(shape: Union[int, Tuple[int, ...]], dtype: _dtypeUnion = ..., order: str = 'C') -> ndarray: ...
